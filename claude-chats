#!/usr/bin/env python3
"""Interactive Claude Code chat manager. Browse, resume, and delete chats."""

import json
import os
import re
import shutil
import sys
import subprocess
import tempfile
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from pathlib import Path

if sys.version_info < (3, 7):
    print("Error: Python 3.7+ required")
    sys.exit(1)

PROJECTS_DIR = Path.home() / ".claude" / "projects"
CONFIG_FILE = Path.home() / ".claude" / "claude-chats.json"

# Dynamic home prefix for stripping paths — works for any user/OS
HOME_PREFIX = str(Path.home()).replace("/", "-").lstrip("-")  # e.g. "home-user"

# ANSI
DIM = "\033[2m"
BOLD = "\033[1m"
CYAN = "\033[36m"
GREEN = "\033[32m"
RED = "\033[31m"
YELLOW = "\033[33m"
MAGENTA = "\033[35m"
RESET = "\033[0m"

FZF_COLORS = ",".join([
    "fg:#c0caf5",
    "bg:#1a1b26",
    "hl:#bb9af7",
    "fg+:#c0caf5",
    "bg+:#292e42",
    "hl+:#7dcfff",
    "info:#7aa2f7",
    "prompt:#7dcfff",
    "pointer:#ff007c",
    "marker:#9ece6a",
    "spinner:#9ece6a",
    "header:#565f89",
    "border:#27a1b9",
    "gutter:#1a1b26",
])

ANSI_RE = re.compile(r'\033\[[^m]*m')

# Sort modes for project list
SORT_MODES = ["name", "chats", "recent"]
SORT_LABELS = {"name": "A-Z", "chats": "Most chats", "recent": "Recent"}


def load_config():
    try:
        with open(CONFIG_FILE, "r") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {}


def save_config(cfg):
    CONFIG_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(CONFIG_FILE, "w") as f:
        json.dump(cfg, f)


def strip_ansi(s):
    return ANSI_RE.sub('', s)


def fzf(lines, header, multi=False, prompt=" ", preview_cmd=None, expect_keys=None):
    """Run fzf. Returns (key, selections)."""
    args = [
        "fzf",
        "--header", header,
        "--header-first",
        "--reverse",
        "--no-sort",
        "--prompt", prompt,
        "--pointer", ">",
        "--marker", "*",
        "--border", "rounded",
        "--border-label-pos", "3",
        "--margin", "1,2",
        "--padding", "0,1",
        "--info", "inline-right",
        "--color", FZF_COLORS,
        "--ansi",
    ]
    binds = ["ctrl-a:select-all"]
    if multi:
        args.append("--multi")
        binds.append("space:toggle+down")
    if expect_keys:
        args.extend(["--expect", ",".join(expect_keys)])
    args.extend(["--bind", ",".join(binds)])
    if preview_cmd:
        args.extend([
            "--preview", preview_cmd,
            "--preview-window", "right:50%:wrap:border-left",
        ])
    try:
        proc = subprocess.Popen(
            args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True,
        )
        stdout, _ = proc.communicate(input="\n".join(lines))
    except FileNotFoundError:
        print("Error: fzf not found. Install with:")
        print("  Ubuntu/Debian: sudo apt install fzf")
        print("  macOS:         brew install fzf")
        sys.exit(1)
    if proc.returncode != 0:
        return "esc", None
    if expect_keys:
        out_lines = stdout.split("\n")
        pressed = out_lines[0].strip()
        selections = [l for l in out_lines[1:] if l.strip()]
        return pressed, selections or None
    selections = [l for l in stdout.strip().split("\n") if l.strip()]
    return None, selections or None


def list_projects():
    projects = []
    for entry in os.scandir(PROJECTS_DIR):
        if not entry.is_dir():
            continue
        name = entry.name
        if name.startswith(f"-{HOME_PREFIX}-"):
            name = name[len(HOME_PREFIX) + 2:]
        elif name == f"-{HOME_PREFIX}":
            name = "~"
        count = 0
        newest = "0"
        for f in os.scandir(entry.path):
            if f.name.endswith(".jsonl") and f.is_file():
                count += 1
                mtime = f.stat().st_mtime
                if str(mtime) > newest:
                    newest = str(mtime)
        projects.append((name, count, entry.path, float(newest) if newest != "0" else 0))
    return projects


SYSTEM_TAGS = ["<local-command-", "<command-name>", "<system-reminder>"]


def _is_system_text(text):
    """Check if text is a system/command message."""
    for tag in SYSTEM_TAGS:
        if tag in text:
            return True
    return False


def _extract_user_text(content):
    """Extract display text from a user message's content field, skipping system messages."""
    if isinstance(content, str) and content.strip():
        if _is_system_text(content):
            return ""
        return content.strip()
    if isinstance(content, list):
        for part in content:
            if isinstance(part, dict) and part.get("type") == "text":
                text = part.get("text", "").strip()
                if text and not _is_system_text(text):
                    return text
    return ""


def parse_one_chat(jsonl_path):
    """Parse metadata from a single chat file."""
    try:
        stat = os.stat(jsonl_path)
        size = stat.st_size
        first_user_msg = ""
        timestamp = ""
        has_assistant = False
        bytes_read = 0
        with open(jsonl_path, "r", errors="replace") as f:
            for line in f:
                bytes_read += len(line)
                if bytes_read > 200000:
                    break
                line = line.strip()
                if not line:
                    continue
                try:
                    data = json.loads(line)
                except json.JSONDecodeError:
                    continue
                if not timestamp and data.get("timestamp"):
                    timestamp = data["timestamp"]
                if data.get("type") == "assistant":
                    has_assistant = True
                if data.get("type") == "user" and not first_user_msg:
                    text = _extract_user_text(data.get("message", {}).get("content", ""))
                    if text:
                        first_user_msg = text
                        break

        first_user_msg = first_user_msg.replace("\n", " ").strip()
        if len(first_user_msg) > 120:
            first_user_msg = first_user_msg[:117] + "..."
        truly_empty = False
        if not first_user_msg:
            first_user_msg = "(resumed session)" if timestamp else "(empty session)"
            truly_empty = not has_assistant

        date_str = ""
        if timestamp:
            try:
                dt = datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
                date_str = dt.strftime("%Y-%m-%d %H:%M")
            except (ValueError, TypeError):
                date_str = timestamp[:16]

        if size < 1024:
            size_str = f"{size}B"
        elif size < 1024 * 1024:
            size_str = f"{size // 1024}K"
        else:
            size_str = f"{size // (1024 * 1024)}M"

        stem = os.path.splitext(jsonl_path)[0]
        return {
            "file": jsonl_path,
            "subagent_dir": stem,
            "date": date_str,
            "size": size_str,
            "message": first_user_msg,
            "truly_empty": truly_empty,
            "timestamp": timestamp or "0",
        }
    except Exception:
        return None


def load_chats(project_dir):
    files = [
        e.path for e in os.scandir(project_dir)
        if e.name.endswith(".jsonl") and e.is_file()
    ]
    if not files:
        return []
    with ThreadPoolExecutor(max_workers=8) as pool:
        results = pool.map(parse_one_chat, files)
    chats = [r for r in results if r is not None]
    chats.sort(key=lambda c: c["timestamp"], reverse=True)
    return chats


def fmt_project_line(name, count, max_name_len):
    padding = max_name_len - len(name) + 2
    if count == 0:
        return f"  {DIM}{name}{' ' * padding}  0 chats{RESET}"
    count_color = GREEN if count < 10 else YELLOW if count < 30 else RED
    return f"  {BOLD}\033[37m{name}{RESET}{' ' * padding}{count_color}{count:>3d}{RESET} {DIM}chats{RESET}"


def fmt_chat_line(idx, chat, idx_width):
    date = chat["date"] or ""
    size = chat["size"]
    msg = chat["message"]
    if msg in ("(empty session)", "(resumed session)"):
        return f"  {DIM}{idx:>{idx_width}}  {date:<16s}  {size:>4s}  {msg}{RESET}"
    return f"  {idx:>{idx_width}}  {DIM}{date:<16s}{RESET}  {YELLOW}{size:>4s}{RESET}  {msg}"


def sort_projects(projects, mode):
    if mode == "name":
        return sorted(projects, key=lambda p: p[0].lower())
    elif mode == "chats":
        return sorted(projects, key=lambda p: (-p[1], p[0].lower()))
    elif mode == "recent":
        return sorted(projects, key=lambda p: -p[3])
    return projects


# ── Preview logic (embedded from claude-chat-preview) ──────────────────────

PREVIEW_FIRST_N = 3
PREVIEW_LAST_N = 4
TS_WIDTH = 12

XML_TAG_RE = re.compile(r'<[^>]+>')


def _preview_clean_text(text):
    text = XML_TAG_RE.sub('', text)
    text = ANSI_RE.sub('', text)
    text = re.sub(r'\n{3,}', '\n\n', text)
    return text.strip()


def _preview_extract_text(content):
    if isinstance(content, str):
        return content
    if isinstance(content, list):
        parts = []
        for part in content:
            if isinstance(part, dict) and part.get("type") == "text":
                parts.append(part["text"])
        return "\n".join(parts)
    return ""


def _preview_is_system(content):
    if isinstance(content, str):
        for tag in SYSTEM_TAGS:
            if tag in content:
                return True
    if isinstance(content, list):
        for part in content:
            if isinstance(part, dict):
                text = part.get("text", "") or part.get("content", "")
                for tag in SYSTEM_TAGS:
                    if tag in text:
                        return True
    return False


def _preview_fmt_timestamp(ts):
    if not ts:
        return " " * TS_WIDTH
    try:
        dt = datetime.fromisoformat(ts.replace("Z", "+00:00"))
        return dt.strftime("%b %d %H:%M")
    except (ValueError, TypeError):
        return " " * TS_WIDTH


def _preview_truncate(text, max_lines=5, max_chars=300):
    lines = text.split("\n")
    remaining = 0
    if len(lines) > max_lines:
        remaining = len(lines) - max_lines
        lines = lines[:max_lines]
    text = "\n".join(lines)
    if len(text) > max_chars:
        text = text[:max_chars]
    if remaining:
        text += f"\n{DIM}+{remaining} more lines{RESET}"
    return text


def _preview_render_message(role, text, ts):
    out = []
    time_str = _preview_fmt_timestamp(ts)
    if role == "user":
        label = f"{GREEN}{BOLD}You   {RESET}"
    else:
        label = f"{MAGENTA}{BOLD}Claude{RESET}"
    out.append(f"  {label}  {DIM}{time_str}{RESET}")
    text = _preview_truncate(text)
    for line in text.split("\n"):
        out.append(f"    {line}")
    return "\n".join(out)


def _preview_print_section(messages, sep):
    for i, (r, t, ts) in enumerate(messages):
        print(_preview_render_message(r, t, ts))
        if i < len(messages) - 1:
            print(sep)


def _preview_read_messages(filepath, seek_from=0, max_bytes=100000):
    messages = []
    with open(filepath, "r", errors="replace") as f:
        if seek_from > 0:
            f.seek(seek_from)
            f.readline()
        bytes_read = 0
        for line in f:
            bytes_read += len(line)
            if bytes_read > max_bytes:
                break
            line = line.strip()
            if not line:
                continue
            try:
                data = json.loads(line)
            except json.JSONDecodeError:
                continue
            msg_type = data.get("type")
            if msg_type == "user":
                raw = data.get("message", {}).get("content", "")
                if _preview_is_system(raw):
                    continue
                content = _preview_clean_text(_preview_extract_text(raw))
                if content:
                    messages.append(("user", content, data.get("timestamp", "")))
            elif msg_type == "assistant":
                content = _preview_clean_text(_preview_extract_text(data.get("message", {}).get("content", "")))
                if content:
                    messages.append(("assistant", content, data.get("timestamp", "")))
    return messages


def preview_main(filepath):
    """Render a chat preview for fzf's preview pane."""
    if not os.path.isfile(filepath):
        print(f"  {DIM}File not found{RESET}")
        return

    file_size = os.path.getsize(filepath)
    cols = int(os.environ.get("FZF_PREVIEW_COLUMNS", 0))
    if not cols:
        try:
            cols = os.get_terminal_size().columns // 2
        except OSError:
            cols = 40
    cols = max(cols - 3, 20)
    sep = f"  {DIM}{CYAN}{'~' * cols}{RESET}"

    first_messages = _preview_read_messages(filepath, seek_from=0, max_bytes=100000)

    read_from = max(0, file_size - 200000)
    last_messages = []
    if read_from > 0:
        last_messages = _preview_read_messages(filepath, seek_from=read_from, max_bytes=200000)

    if not first_messages and not last_messages:
        print(f"\n  {DIM}No messages{RESET}")
        return

    print()

    if read_from == 0:
        msgs = first_messages
        total = len(msgs)
        if total <= PREVIEW_FIRST_N + PREVIEW_LAST_N:
            _preview_print_section(msgs, sep)
        else:
            _preview_print_section(msgs[:PREVIEW_FIRST_N], sep)
            skipped = total - PREVIEW_FIRST_N - PREVIEW_LAST_N
            print(f"\n  {DIM}{YELLOW}        ~ {skipped} skipped{RESET}\n")
            _preview_print_section(msgs[-PREVIEW_LAST_N:], sep)
    else:
        _preview_print_section(first_messages[:PREVIEW_FIRST_N], sep)
        print(f"\n  {DIM}{YELLOW}        ~  ...  {RESET}\n")
        _preview_print_section(last_messages[-PREVIEW_LAST_N:], sep)

    print()


# ── Main UI ────────────────────────────────────────────────────────────────

def print_help():
    print("claude-chats - Browse and manage Claude Code conversations")
    print()
    print("Usage: claude-chats [OPTIONS]")
    print()
    print("Options:")
    print("  --help       Show this help message")
    print()
    print("Project view:")
    print("  enter    Browse conversations in selected project")
    print("  tab      Cycle sort order (A-Z / Most chats / Recent)")
    print("  esc      Quit")
    print()
    print("Chat view:")
    print("  enter    Resume highlighted conversation in Claude Code")
    print("  space    Toggle selection")
    print("  ctrl-a   Select all")
    print("  ctrl-x   Delete selected conversations")
    print("  ctrl-d   Purge empty sessions (no real content)")
    print("  backspace  Back to project list")
    print("  esc      Quit")
    print()
    print("Requirements: Python 3.7+, fzf")


def main():
    # Handle --preview (self-invoked by fzf)
    if len(sys.argv) >= 2 and sys.argv[1] == "--preview":
        if len(sys.argv) >= 3:
            preview_main(sys.argv[2])
        return

    # Handle --help
    if len(sys.argv) >= 2 and sys.argv[1] in ("--help", "-h"):
        print_help()
        return

    # Check projects directory exists
    if not PROJECTS_DIR.exists():
        print("No Claude Code projects found.")
        print(f"Expected: {PROJECTS_DIR}")
        sys.exit(0)

    cfg = load_config()
    saved_sort = cfg.get("sort", "name")
    sort_idx = SORT_MODES.index(saved_sort) if saved_sort in SORT_MODES else 0

    while True:
        projects = list_projects()
        if not projects:
            print("No chats found.")
            return

        sort_mode = SORT_MODES[sort_idx]
        sorted_proj = sort_projects(projects, sort_mode)

        total = sum(c for _, c, _, _ in projects)
        max_name_len = max(len(name) for name, _, _, _ in projects)

        lines = []
        project_map = {}
        for name, count, path, _ in sorted_proj:
            lines.append(fmt_project_line(name, count, max_name_len))
            project_map[name] = (path, count)

        os.system("clear")
        sort_label = SORT_LABELS[sort_mode]
        header = (
            f"  {DIM}{total} conversations across {len(projects)} projects{RESET}"
            f"    {DIM}enter{RESET} browse  {DIM}tab{RESET} sort ({CYAN}{sort_label}{RESET})  {DIM}esc{RESET} quit"
        )
        key, selected = fzf(lines, header, prompt=" Projects > ", expect_keys=["tab"])

        if key == "esc":
            return
        if key == "tab":
            sort_idx = (sort_idx + 1) % len(SORT_MODES)
            cfg["sort"] = SORT_MODES[sort_idx]
            save_config(cfg)
            continue
        if not selected:
            return

        clean = strip_ansi(selected[0]).strip()
        project_name = clean.split()[0]
        if project_name not in project_map:
            continue

        path, count = project_map[project_name]

        if count == 0:
            os.system("clear")
            print()
            print(f"  {BOLD}{project_name}{RESET}  {DIM}has no conversations.{RESET}")
            print()
            answer = input(f"  {DIM}Delete empty folder? (y/N):{RESET} ").strip().lower()
            if answer == "y":
                shutil.rmtree(path, ignore_errors=True)
                print(f"\n  {GREEN}{BOLD}Deleted folder.{RESET}\n")
            else:
                print(f"\n  {DIM}Skipped.{RESET}\n")
            input(f"  {DIM}Press Enter...{RESET}")
            continue

        sys.stdout.write(f"  {DIM}Loading {project_name}...{RESET}")
        sys.stdout.flush()
        chats = load_chats(path)
        os.system("clear")

        if not chats:
            continue

        map_fd, map_path = tempfile.mkstemp(suffix=".txt")
        with os.fdopen(map_fd, "w") as mf:
            for chat in chats:
                mf.write(chat["file"] + "\n")

        idx_width = len(str(len(chats) - 1))
        chat_lines = []
        for i, chat in enumerate(chats):
            chat_lines.append(fmt_chat_line(i, chat, idx_width))

        # Only count sessions with zero real content (no user or assistant messages)
        empty_indices = [i for i, c in enumerate(chats) if c["truly_empty"]]
        empty_hint = f"  {DIM}ctrl-d{RESET} purge {len(empty_indices)} empty" if empty_indices else ""

        keys_line = f"  {DIM}enter{RESET} resume  {DIM}space{RESET} select  {DIM}ctrl-x{RESET} delete  {DIM}backspace{RESET} back  {DIM}esc{RESET} quit{empty_hint}"
        header = (
            f"  {BOLD}{project_name}{RESET}  {DIM}{len(chats)} conversations{RESET}\n"
            f"{keys_line}"
        )
        script = os.path.realpath(__file__)
        preview = f'"{script}" --preview "$(sed -n "$(expr {{n}} + 1)p" {map_path})"'
        key, selected = fzf(
            chat_lines, header, multi=True,
            prompt=" ",
            preview_cmd=preview, expect_keys=["bs", "ctrl-d", "ctrl-x"],
        )

        os.unlink(map_path)

        if key == "esc":
            return
        if key == "bs" or (not selected and key not in ("ctrl-d", "ctrl-x")):
            continue

        # Resume: enter (key="") with a single selection
        if key == "" and selected:
            clean = strip_ansi(selected[0]).strip()
            if clean:
                idx = int(clean.split()[0])
                session_id = os.path.splitext(os.path.basename(chats[idx]["file"]))[0]
                os.execvp("claude", ["claude", "--resume", session_id])

        if key == "ctrl-d":
            if not empty_indices:
                continue
            indices = empty_indices
        elif key == "ctrl-x":
            indices = []
            for line in selected:
                clean = strip_ansi(line).strip()
                if clean:
                    indices.append(int(clean.split()[0]))

            if not indices:
                continue
        else:
            continue

        os.system("clear")
        try:
            cols = os.get_terminal_size().columns
        except OSError:
            cols = 80

        n = len(indices)
        label = f"conversation{'s' if n != 1 else ''}"
        total_size = 0
        for idx in indices:
            try:
                total_size += os.path.getsize(chats[idx]["file"])
            except OSError:
                pass
        if total_size < 1024:
            size_str = f"{total_size}B"
        elif total_size < 1024 * 1024:
            size_str = f"{total_size // 1024}KB"
        else:
            size_str = f"{total_size // (1024 * 1024)}MB"

        print()
        print(f"  {RED}{'~' * (cols - 4)}{RESET}")
        print()
        print(f"  {RED}{BOLD}  Delete {n} {label}{RESET}  {DIM}({size_str}){RESET}")
        print(f"  {DIM}  from {BOLD}{project_name}{RESET}")
        print()
        print(f"  {RED}{'~' * (cols - 4)}{RESET}")
        print()

        for idx in indices:
            chat = chats[idx]
            date = chat['date'] or '              '
            size = chat['size']
            msg = chat['message'][:65]
            print(f"    {RED}x{RESET}  {DIM}{date:<16s}{RESET}  {YELLOW}{size:>4s}{RESET}  {msg}")

        print()
        print(f"  {RED}{'~' * (cols - 4)}{RESET}")
        print()
        answer = input(f"  {BOLD}Confirm delete? {RED}y{RESET}{DIM}/{RESET}{GREEN}N{RESET} ").strip().lower()

        if answer != "y":
            print(f"\n  {DIM}Cancelled.{RESET}")
            input(f"\n  {DIM}Press Enter...{RESET}")
            continue

        deleted = 0
        for idx in indices:
            chat = chats[idx]
            try:
                os.remove(chat["file"])
                deleted += 1
            except OSError as e:
                print(f"  {RED}Error: {e}{RESET}")
            sub = chat["subagent_dir"]
            if os.path.isdir(sub):
                shutil.rmtree(sub, ignore_errors=True)

        print()
        print(f"  {GREEN}{BOLD}  Deleted {deleted} {label}.{RESET}")
        print()
        input(f"  {DIM}Press Enter...{RESET}")


if __name__ == "__main__":
    main()
